import argparse
import json
import time
import shutil
import sys
import re
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple, Union

from watchdog.observers import Observer
from watchdog.events import FileSystemEventHandler

import pyautogui
import pyperclip

# ====================== CONFIG ======================
BASE = Path(__file__).parent
INBOX = BASE / "inbox"
PROCESSED = BASE / "processed"
FAILED = BASE / "failed"
OUTBOX = BASE / "outbox_prompts"

COORD_FILE = BASE / "chatgpt_input_xy.json"

FILE_STABILIZE_SEC = 0.25

# automation timing
COUNTDOWN_SECONDS = 5       
FOCUS_DELAY_SEC = 0.20
PASTE_DELAY_SEC = 0.10
ENTER_DELAY_SEC = 0.10
RETRY_PASTE = 2

MAX_LIST_ITEMS = 14

pyautogui.FAILSAFE = True  
# ====================================================





def _is_blank(x: Any) -> bool:
    return x is None or x == "" or x == {} or x == []


def summarize(v: Any, max_items: int = MAX_LIST_ITEMS) -> str:
    if v is None:
        return "None"
    if isinstance(v, (str, int, float, bool)):
        return str(v)
    if isinstance(v, list):
        if not v:
            return "None"
        items = [summarize(x, max_items=max_items) for x in v[:max_items]]
        extra = f" …(+{len(v)-max_items} more)" if len(v) > max_items else ""
        return ", ".join(items) + extra
    if isinstance(v, dict):
        if not v:
            return "None"
        keys = list(v.keys())
        shown = keys[:max_items]
        extra = f" …(+{len(keys)-max_items} more)" if len(keys) > max_items else ""
        return ", ".join(map(str, shown)) + extra
    return str(v)


def normalize_side(raw: Any) -> Optional[str]:
    if _is_blank(raw):
        return None
    s = str(raw).strip().lower()
    if s in ("i", "israel", "blue", "blue (israel)"):
        return "Blue (Israel)"
    if s in ("r", "iran", "red", "red (iran)"):
        return "Red (Iran)"
    return str(raw)


def read_json_with_retry(path: Path, retries: int = 12, delay: float = 0.15) -> Dict[str, Any]:
    last_err = None
    for _ in range(retries):
        try:
            return json.loads(path.read_text(encoding="utf-8"))
        except Exception as e:
            last_err = e
            time.sleep(delay)
    raise RuntimeError(f"Failed to read/parse {path.name}: {last_err}")


def unwrap_state(payload: Dict[str, Any]) -> Tuple[Dict[str, Any], Dict[str, Any]]:
    # payload could be {"game_id":..., "side":..., "state":{...}}
    if isinstance(payload, dict) and isinstance(payload.get("state"), dict):
        return payload, payload["state"]
    return payload, payload


def get_first(d: Any, keys: List[str]) -> Any:
    if not isinstance(d, dict):
        return None
    for k in keys:
        if k in d:
            return d[k]
    return None


def label_card(side_norm: str, card_id):
    try:
        n = int(card_id)
    except Exception:
        return str(card_id)

    if "Israel" in side_norm:
        c = ISRAEL_CARD_MAP.get(n)
    elif "Iran" in side_norm:
        c = IRAN_CARD_MAP.get(n)
    else:
        c = ISRAEL_CARD_MAP.get(n) or IRAN_CARD_MAP.get(n)

    name = c.get("Name") if isinstance(c, dict) else None
    return f"{n} — {name}" if name else str(n)



def extract_turn_info(outer: Dict[str, Any], st: Dict[str, Any]) -> Tuple[Optional[Any], Optional[str], Optional[str]]:
    turn = st.get("turn") if isinstance(st.get("turn"), dict) else (st.get("t") if isinstance(st.get("t"), dict) else {})
    map_turn = get_first(turn, ["map_turn", "mapTurn", "turn_number", "turnNumber", "number", "n"]) or get_first(st, ["map_turn", "turn_number"])
    phase = get_first(turn, ["phase", "time_of_day", "timeOfDay", "segment", "ts"]) or get_first(st, ["phase", "segment"])
    segment = get_first(turn, ["segment", "time_of_day", "timeOfDay", "tod"])
    if isinstance(phase, str):
        ph = phase.strip().lower()
        if ph in ("m", "morning"):
            phase = "Morning"
        elif ph in ("a", "afternoon"):
            phase = "Afternoon"
        elif ph in ("n", "night"):
            phase = "Night"

    side_raw = outer.get("side") or get_first(turn, ["side", "side_to_act", "current_player", "s"]) or get_first(st, ["side", "side_to_act", "current_player"])
    side = normalize_side(side_raw)
    return map_turn, segment, phase, side


def extract_points(st: Dict[str, Any]) -> Tuple[Optional[Dict[str, Any]], Optional[Dict[str, Any]]]:
    r = st.get("r") if isinstance(st.get("r"), dict) else None
    players = st.get("players") if isinstance(st.get("players"), dict) else None
    resources = st.get("resources") if isinstance(st.get("resources"), dict) else None

    def norm_pts(obj: Any) -> Optional[Dict[str, Any]]:
        if not isinstance(obj, dict):
            return None
        if "resources" in obj and isinstance(obj["resources"], dict):
            obj = obj["resources"]
        mp = get_first(obj, ["MP", "mp", "m"])
        ip = get_first(obj, ["IP", "ip", "i"])
        pp = get_first(obj, ["PP", "pp", "p"])
        if mp is None and ip is None and pp is None:
            return None
        return {"mp": mp, "ip": ip, "pp": pp}

    blue = None
    red = None

    if r:
        for k in r.keys():
            kl = str(k).lower()
            if kl in ("israel", "blue"):
                blue = norm_pts(r[k]) or blue
            if kl in ("iran", "red"):
                red = norm_pts(r[k]) or red

    if players:
        for k in players.keys():
            kl = str(k).lower()
            if kl in ("israel", "blue"):
                blue = norm_pts(players[k]) or blue
            if kl in ("iran", "red"):
                red = norm_pts(players[k]) or red

    if resources:
        for k in resources.keys():
            kl = str(k).lower()
            if kl in ("israel", "blue"):
                blue = norm_pts(resources[k]) or blue
            if kl in ("iran", "red"):
                red = norm_pts(resources[k]) or red

    return blue, red


def extract_opinion(st: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    for k in ("o", "opinion", "opinions", "tracks"):
        if isinstance(st.get(k), dict):
            return st[k]
    return None


def extract_rivers(st: Dict[str, Any]) -> Optional[Dict[str, Any]]:
    rvr = st.get("rvr")
    if isinstance(rvr, dict) and rvr:
        return rvr
    river = st.get("river")
    if isinstance(river, dict) and river:
        return river
    return None

def get_card_details(side_norm: str, card_id: Any) -> Optional[Dict[str, Any]]:
    try:
        n = int(card_id)
    except:
        return None
    
    # Check which side owns the card to look up the correct text
    if "Israel" in side_norm:
        return ISRAEL_CARD_MAP.get(n)
    elif "Iran" in side_norm:
        return IRAN_CARD_MAP.get(n)
    else:
        # Fallback: check both if side is unclear
        return ISRAEL_CARD_MAP.get(n) or IRAN_CARD_MAP.get(n)

def build_prompt(payload: Dict[str, Any]) -> str:
    outer, st = unwrap_state(payload)
    map_turn, segment, phase, side_to_act = extract_turn_info(outer, st)
    blue_pts, red_pts = extract_points(st)
    opinion = extract_opinion(st)
    rivers = extract_rivers(st)

    queue = get_first(st, ["active_events_queue", "queue", "queues", "planned_actions", "planned"])
    readiness = get_first(st, ["as", "readiness", "forces", "air", "aircraft", "squadrons", "units"])
    upgrades = get_first(st, ["u", "upgrades"])
    bm = get_first(st, ["bm", "ballistic_missiles"])
    swm = get_first(st, ["swm", "special_warfare", "special_war"])
    damage = get_first(st, ["ti", "target_impacts", "damage", "losses", "target_folders"])
    strategic = get_first(st, ["strategic_event_impact", "strategic_effects", "effects", "active_effects"])
    notes = st.get("notes") or outer.get("notes")

    lines: List[str] = []
    lines.append("Continue Persian Incursion simulation.")
    lines.append("")
    lines.append("STATE SUMMARY")
    if map_turn is not None:
        lines.append(f"- Map Turn: {map_turn}")
    if phase:
        lines.append(f"- Phase: {phase}")
    if segment:
        lines.append(f"- Segment: {segment}")
    if side_to_act:
        lines.append(f"- Side to act: {side_to_act}")

    lines.append("")
    lines.append("POINTS / RESOURCES")
    if blue_pts:
        lines.append(f"- Blue (Israel): MP {blue_pts.get('mp')}, IP {blue_pts.get('ip')}, PP {blue_pts.get('pp')}")
    else:
        lines.append("- Blue (Israel): (missing)")
    if red_pts:
        lines.append(f"- Red (Iran): MP {red_pts.get('mp')}, IP {red_pts.get('ip')}, PP {red_pts.get('pp')}")
    else:
        lines.append("- Red (Iran): (missing)")

    lines.append("")
    lines.append("OPINION TRACKS")
    if isinstance(opinion, dict):
        d = opinion.get("d") or opinion.get("domestic") or {}
        tp = opinion.get("tp") or opinion.get("third_parties") or {}

        # [FIXED INDENTATION]
        lines.append(f"- Domestic: Israel {d.get('i', 0)}, Iran {d.get('r', 0)}")
        lines.append(
            "- Third Parties: "
            f"US {tp.get('u', 0)}, UN {tp.get('un', 0)}, SA/GCC {tp.get('sa', 0)}, "
            f"Turkey {tp.get('t', 0)}, Jordan {tp.get('jo', 0)}, Russia {tp.get('ru', 0)}, China {tp.get('c', 0)}"
        )
    else:
        lines.append("- (missing)")

    # Track which cards we need to explain to the AI
    cards_to_reference = set()

    lines.append("")
    lines.append("CARD RIVERS (7 slots)")
    if rivers:
        for k, arr in rivers.items():
            norm = str(k)
            if isinstance(arr, list):
                slots = []
                # Infer side (Israel/Iran) from the key name to look up correct text
                kl = str(k).lower()
                side_label = "Israel" if ("israel" in kl or "blue" in kl) else "Iran"
                
                for i in range(7):
                    cid = arr[i] if i < len(arr) else None
                    if cid is None:
                        slots.append(f"{i+1}:(empty)")
                    else:
                        label = label_card(side_label, cid)
                        slots.append(f"{i+1}:[{label}]")
                        # Save for the reference section below
                        cards_to_reference.add((side_label, cid))
                lines.append(f"- {norm}: " + " | ".join(slots))
            else:
                lines.append(f"- {norm}: {summarize(arr)}")
    else:
        lines.append("- (missing)")

    # [NEW SECTION] INJECT CARD RULES TEXT
    if cards_to_reference:
        lines.append("")
        lines.append("CARD TEXT REFERENCE (Authoritative)")
        for side_label, cid in cards_to_reference:
            details = get_card_details(side_label, cid)
            if details:
                # Format: [ID] Name | Cost: X | Effect: Y
                lines.append(f"• [{cid}] {details.get('Name', 'Unknown')}")
                lines.append(f"   Cost: {details.get('Cost')} | Effect: {details.get('Effect')}")
                if details.get('Notes'):
                    lines.append(f"   Notes: {details.get('Notes')}")
            else:
                lines.append(f"• [{cid}] (Text not found in internal database)")

    lines.append("")
    lines.append("QUEUED / PLANNED ACTIONS")
    if not queue:
        lines.append("- None (explicit): No planned/queued actions exist.")
    else:
        lines.append(f"- {summarize(queue)}")

    lines.append("")
    lines.append("FORCE READINESS")
    if not readiness:
        lines.append("- None (explicit): Treat as unknown/default.")
    else:
        lines.append(f"- {summarize(readiness)}")

    lines.append("")
    lines.append("BALLISTIC MISSILES")
    if not bm:
        lines.append("- None (explicit): Treat as unknown.")
    else:
        lines.append(f"- {summarize(bm)}")

    lines.append("")
    lines.append("SPECIAL WARFARE")
    if not swm:
        lines.append("- None (explicit): No SWM active.")
    else:
        lines.append(f"- {summarize(swm)}")

    lines.append("")
    lines.append("UPGRADES")
    if not upgrades:
        lines.append("- None (explicit): No upgrades active.")
    else:
        lines.append(f"- {summarize(upgrades)}")

    lines.append("")
    lines.append("STRATEGIC EFFECTS")
    if not strategic:
        lines.append("- None (explicit): No strategic effects.")
    else:
        lines.append(f"- {summarize(strategic)}")

    lines.append("")
    lines.append("DAMAGE / LOSSES")
    if not damage:
        lines.append("- None (explicit): No damage.")
    else:
        lines.append(f"- {summarize(damage)}")

    if notes:
        lines.append("")
        lines.append("NOTES")
        lines.append(f"- {summarize(notes)}")

    lines.append("")
    lines.append("AI CONTROL INSTRUCTIONS")
    lines.append("1. The side to act is AI-controlled.")
    lines.append("2. Read the CARD TEXT REFERENCE above for card effects.")
    lines.append("3. Execute actions immediately according to rules.")
    lines.append("4. Continue selecting and resolving optimal actions until PASS.")
    lines.append("5. If any required rule-critical state is missing, STOP and request the exact missing fields. Do not assume defaults.")

    return "\n".join(lines)

IRAN_CARDS = [
    {"No": 1, "Name": "Ahmadinejad Speech", "Quantity": 3, "Cost": "1P", "Effect": "3● Ir Domest, Is Domestic, SA, J, T, R, C, US", "Notes": "Backfire 7 - Opponent Rolls"},
    {"No": 2, "Name": "Antiwar Protests", "Quantity": 2, "Cost": "6P", "Effect": "4●+4● Is Domestic, US, UN", "Notes": ""},
    {"No": 3, "Name": "Appeal to the Faithful", "Quantity": 1, "Cost": "3P", "Effect": "1● Ir Domestic", "Notes": ""},
    {"No": 4, "Name": "Arms Purchase", "Quantity": 1, "Cost": "5M", "Effect": "Immediately receive any combination of upgrades costing up to 40 points", "Notes": "Supplying nation must be Supporter or Ally"},
    {"No": 5, "Name": "Black Market", "Quantity": 2, "Cost": "--", "Effect": "For every three points spent receive 1 point of any type the player chooses", "Notes": "+1 point of retrieved card’s first cost"},
    {"No": 6, "Name": "Careful Planning", "Quantity": 3, "Cost": "2P", "Effect": "Retrieve 1 card from discard", "Notes": ""},
    {"No": 7, "Name": "Collateral Damage", "Quantity": 3, "Cost": "2P", "Effect": "1●+1●+1● SA, J, T, R, US, UN", "Notes": "Requires: Israel has launched an airstrike this Map Turn"},
    {"No": 8, "Name": "Crackdown on Dissent", "Quantity": 2, "Cost": "2M", "Effect": "1● Ir Domestic", "Notes": "Backfire 8 - Opponent Rolls"},
    {"No": 9, "Name": "Carnage for the Cameras", "Quantity": 1, "Cost": "4P", "Effect": "1●+1● SA, J, T, R, US, UN", "Notes": "Dirty"},
    {"No": 10, "Name": "Fanning the Flames", "Quantity": 2, "Cost": "4P", "Effect": "1● SA, J, T, UN + 1● UN", "Notes": ""},
    {"No": 11, "Name": "Friendship Prices", "Quantity": 2, "Cost": "4P", "Effect": "3●+3● UN, C", "Notes": ""},
    {"No": 12, "Name": "Funding Opposition", "Quantity": 1, "Cost": "3I", "Effect": "3● Is Domestic", "Notes": "Covert"},
    {"No": 13, "Name": "High-Level Indecision", "Quantity": 1, "Cost": "4I", "Effect": "Discard a card from opponent’s River", "Notes": ""},
    {"No": 14, "Name": "Human Interest Story", "Quantity": 1, "Cost": "2P", "Effect": "3● IS, US, UN, SA, J", "Notes": ""},
    {"No": 15, "Name": "Illicit Bribery", "Quantity": 1, "Cost": "5I", "Effect": "Discard 2 cards (random) from opponent’s River", "Notes": "Dirty"},
    {"No": 16, "Name": "Incriminating Photos", "Quantity": 2, "Cost": "4P", "Effect": "4● Ir Domestic, J, SA, T", "Notes": "Dirty"},
    {"No": 17, "Name": "International Divestment", "Quantity": 1, "Cost": "2P", "Effect": "3● US, UN", "Notes": ""},
    {"No": 18, "Name": "Israeli Condemnation", "Quantity": 1, "Cost": "7P", "Effect": "7● Is Domestic", "Notes": ""},
    {"No": 19, "Name": "Major Expose", "Quantity": 2, "Cost": "3P", "Effect": "4●+4●+4● Ir Domestic, SA, J, T, R, C, US, UN", "Notes": "Requires last opponent act to be Dirty"},
    {"No": 20, "Name": "Official Coverup", "Quantity": 2, "Cost": "2P, 2I, 2M", "Effect": "Cancel Strategic Event", "Notes": "Covert"},
    {"No": 21, "Name": "On-Call Kill Team", "Quantity": 1, "Cost": "5I", "Effect": "Cancel opponent’s card whose first cost is I", "Notes": "Covert"},
    {"No": 22, "Name": "OPEC Diplomacy", "Quantity": 1, "Cost": "5P", "Effect": "3●+3● SA, J, C", "Notes": ""},
    {"No": 23, "Name": "Palestinian Unrest", "Quantity": 2, "Cost": "3P", "Effect": "1● SA, J, T + 1D 3● Is Domestic", "Notes": "Dirty"},
    {"No": 24, "Name": "Plausible Deniability", "Quantity": 1, "Cost": "3P", "Effect": "4● SA, J, T or 3● Is Domestic", "Notes": "Dirty. Requires: Must have captured at least one Israeli POW"},
    {"No": 25, "Name": "POWs on TV", "Quantity": 2, "Cost": "4P", "Effect": "3●+3● Is Domestic, Ir Domestic, UN", "Notes": ""},
    {"No": 26, "Name": "Press Leak", "Quantity": 2, "Cost": "3P", "Effect": "3●+3●+3● SA, J, T, R, C, US, UN", "Notes": "Requires: Last opponent act was Covert or Dirty"},
    {"No": 27, "Name": "Promised Concessions", "Quantity": 1, "Cost": "4P", "Effect": "3●+3● R, C, US", "Notes": ""},
    {"No": 28, "Name": "Propaganda Barrage", "Quantity": 2, "Cost": "4P", "Effect": "3●+3● SA, J, T", "Notes": ""},
    {"No": 29, "Name": "Protests in Tel Aviv", "Quantity": 1, "Cost": "5P", "Effect": "4● Is Domestic", "Notes": ""},
    {"No": 30, "Name": "Quick Spin Control", "Quantity": 1, "Cost": "6P", "Effect": "Cancel opponent’s card whose first cost is P", "Notes": ""},
    {"No": 31, "Name": "Radical Elements", "Quantity": 1, "Cost": "4P", "Effect": "3●+3● SA, J, T", "Notes": "Backfire 10 - Opponent Rolls"},
    {"No": 32, "Name": "Sleeper Agent", "Quantity": 2, "Cost": "4I", "Effect": "Look at opponent’s River", "Notes": ""},
    {"No": 33, "Name": "Staged Protest", "Quantity": 1, "Cost": "4I", "Effect": "3● IS, UN", "Notes": ""}, # Note: 'IS' likely means 'Israeli Domestic', confirmed from rulebook context.
    {"No": 34, "Name": "Superpower Pressure", "Quantity": 1, "Cost": "4P", "Effect": "5● SA, T", "Notes": "Requires either R or C Supporter or Ally"}
]
IRAN_CARD_MAP = {c["No"]: c for c in IRAN_CARDS}

ISRAEL_CARDS = [
    {"No": 1, "Name": "Appeal to the Electorate", "Quantity": 1, "Cost": "3P", "Effect": "1● Is Domestic", "Notes": ""},
    {"No": 2, "Name": "Arms Purchase", "Quantity": 1, "Cost": "5M", "Effect": "Immediately receive any combination of upgrades costing up to 40 points", "Notes": "Supplying nation must be Supporter or Ally"},
    {"No": 3, "Name": "Black Market", "Quantity": 2, "Cost": "--", "Effect": "For every three points spent receive 1 point of any type the player chooses", "Notes": "+1 point of retrieved card’s first cost"},
    {"No": 4, "Name": "Illicit Bribery", "Quantity": 1, "Cost": "5I", "Effect": "Discard 2 cards (random) from opponent’s River", "Notes": "Dirty"},
    {"No": 5, "Name": "Careful Planning", "Quantity": 2, "Cost": "2P", "Effect": "Retrieve 1 card from discard", "Notes": ""},
    {"No": 6, "Name": "Collective Anxiety", "Quantity": 1, "Cost": "4P", "Effect": "4●+4● SA, J, T, Is domestic", "Notes": ""},
    {"No": 7, "Name": "Congressional Lobby", "Quantity": 1, "Cost": "2P", "Effect": "1● US", "Notes": ""},
    {"No": 8, "Name": "Cruiser Deployment", "Quantity": 1, "Cost": "4M", "Effect": "Add Bunker Hull-class GC to ballistic Missile Defenses", "Notes": "US is Supporter or Ally"},
    {"No": 9, "Name": "Destroyer Deployment", "Quantity": 1, "Cost": "3M", "Effect": "Add Burke-class DDG to ballistic Missile Defenses", "Notes": "US is Supporter or Ally"},
    {"No": 10, "Name": "Fallout Zone Anxiety", "Quantity": 1, "Cost": "4P", "Effect": "4● SA, J, T", "Notes": ""},
    {"No": 11, "Name": "Fanning the Flames", "Quantity": 1, "Cost": "4P", "Effect": "1● SA, J, T, UN + 1● UN", "Notes": ""},
    {"No": 12, "Name": "Favorable Media", "Quantity": 2, "Cost": "4P", "Effect": "4●+4● US, R, UN, Is Domestic", "Notes": ""},
    {"No": 13, "Name": "Firm Commitment", "Quantity": 2, "Cost": "5P", "Effect": "Choose one of the three required countries. The country’s Opinion Track cannot be moved at all for D6+3 Map Turns", "Notes": ""},
    {"No": 14, "Name": "Flyover Negotiations", "Quantity": 3, "Cost": "5P", "Effect": "5● SA, T", "Notes": ""},
    {"No": 15, "Name": "Focused Diplomacy", "Quantity": 2, "Cost": "4P", "Effect": "3● SA, J, T, US, R, C, UN", "Notes": ""},
    {"No": 16, "Name": "Funding Opposition", "Quantity": 1, "Cost": "3I", "Effect": "3● Is Domestic", "Notes": "Covert"},
    {"No": 17, "Name": "Gulfside Negotiations", "Quantity": 2, "Cost": "4P", "Effect": "4● SA, J", "Notes": ""},
    {"No": 18, "Name": "High-Level Indecision", "Quantity": 1, "Cost": "4I", "Effect": "Discard a card from opponent’s River", "Notes": ""},
    {"No": 19, "Name": "Incriminating Photos", "Quantity": 2, "Cost": "4P", "Effect": "4● Ir Domestic, J, SA, T", "Notes": "Dirty"},
    {"No": 20, "Name": "Israeli Outrage", "Quantity": 2, "Cost": "3P", "Effect": "3● Is Domestic", "Notes": "Requires Iranian Overt act"},
    {"No": 21, "Name": "Long-Term Interests", "Quantity": 1, "Cost": "5P", "Effect": "3●+3●+3● SA, US, C, UN", "Notes": ""},
    {"No": 22, "Name": "Major Expose", "Quantity": 2, "Cost": "3P", "Effect": "4●+4●+4● Ir Domestic, SA, J, T, R, C, US, UN", "Notes": "Requires last opponent act to be Dirty"},
    {"No": 23, "Name": "Manufactured Attack", "Quantity": 1, "Cost": "4I", "Effect": "4● SA, J, T, UN, Is Domestic", "Notes": "Dirty"},
    {"No": 24, "Name": "Media Reaction", "Quantity": 1, "Cost": "3P", "Effect": "3●+3● US, R, UN", "Notes": "Requires previous Iranian Overt act"},
    {"No": 25, "Name": "Nuclear Proof", "Quantity": 1, "Cost": "3P, 3I", "Effect": "3●+3● SA, J, T, US, R, C, US, UN, Is Domestic", "Notes": "Requires at least 1 nuclear target destroyed or crippled"},
    {"No": 26, "Name": "Official Coverup", "Quantity": 2, "Cost": "2P, 2I, 2M", "Effect": "Cancel Strategic Event", "Notes": ""},
    {"No": 27, "Name": "On-Call Kill Team", "Quantity": 1, "Cost": "5I", "Effect": "Cancel opponent’s card whose first cost is I", "Notes": "Covert"},
    {"No": 28, "Name": "Overzealous Pasdaran", "Quantity": 1, "Cost": "3P", "Effect": "4●+4● SA, J, T, US, UN, Is Domestic", "Notes": "Add Cost 3I. Requires previous Iranian Overt"},
    {"No": 29, "Name": "Plausible Deniability", "Quantity": 1, "Cost": "5I", "Effect": "4● SA, J, T or 3● Ir Domestic", "Notes": "Dirty"},
    {"No": 30, "Name": "Press Leak", "Quantity": 2, "Cost": "3P", "Effect": "3●+3●+3● SA, J, T, R, C, US, UN", "Notes": "Requires: Last opponent act was Covert or Dirty"},
    {"No": 31, "Name": "Protests in Tehran", "Quantity": 2, "Cost": "5P", "Effect": "4● Ir Domestic", "Notes": ""},
    {"No": 32, "Name": "Quick Spin Control", "Quantity": 1, "Cost": "6P", "Effect": "Cancel opponent’s card whose first cost is P", "Notes": ""},
    {"No": 33, "Name": "Sleeper Agent", "Quantity": 2, "Cost": "4I", "Effect": "Look at opponent’s River", "Notes": ""},
    {"No": 34, "Name": "Speech of Support", "Quantity": 2, "Cost": "3P", "Effect": "3● US, Is domestic", "Notes": ""},
    {"No": 35, "Name": "Technology Transfer", "Quantity": 1, "Cost": "4M", "Effect": "3● C, R", "Notes": "Backfire – Ir receives 3● US."},
    {"No": 36, "Name": "UN Resolution", "Quantity": 1, "Cost": "1P", "Effect": "1● UN, Is Domestic", "Notes": "Israel still 3● C, R, dice if Backfire is rolled."}, # Typo fixed from 'Resoulution'
    {"No": 37, "Name": "Widespread Condemnation", "Quantity": 1, "Cost": "7P", "Effect": "7● Ir Domestic", "Notes": "Israel still 3● C, R, dice if Backfire is rolled."},
    {"No": 38, "Name": "Worried Leaders", "Quantity": 1, "Cost": "7P", "Effect": "4●+4●+4● SA,J,T,R,C,UN, US", "Notes": ""} # Typo fixed from ',J,'
]
ISRAEL_CARD_MAP = {c["No"]: c for c in ISRAEL_CARDS}
# ------------------ XY Capture / Load ------------------
def capture_click_point(countdown: int = COUNTDOWN_SECONDS) -> Dict[str, int]:
    print(f"[SETUP] {countdown} seconds later mouse pointer would be saved as  'ChatGPT prompt coordinates.", flush=True)
    for i in range(countdown, 0, -1):
        print(f"[SETUP] {i}...", flush=True)
        time.sleep(1)
    x, y = pyautogui.position()
    data = {"x": int(x), "y": int(y)}
    COORD_FILE.write_text(json.dumps(data, ensure_ascii=False), encoding="utf-8")
    print(f"[SETUP] Saved input XY => {data}  ({COORD_FILE})", flush=True)
    return data


def load_click_point() -> Dict[str, int]:
    if COORD_FILE.exists():
        try:
            data = json.loads(COORD_FILE.read_text(encoding="utf-8"))
            return {"x": int(data["x"]), "y": int(data["y"])}
        except Exception:
            pass
    return capture_click_point()


# ------------------ Paste Automation ------------------
def paste_into_open_chatgpt(prompt: str) -> None:
    if not prompt or not prompt.strip():
        raise RuntimeError("Prompt is empty. Nothing to paste.")

    xy = load_click_point()

    print(f"[AUTO] {COUNTDOWN_SECONDS}초 뒤에 붙여넣고 Enter 전송합니다.", flush=True)
    for i in range(COUNTDOWN_SECONDS, 0, -1):
        print(f"[AUTO] {i}...", flush=True)
        time.sleep(1)

    pyperclip.copy(prompt)
    time.sleep(0.05)

    time.sleep(FOCUS_DELAY_SEC)
    pyautogui.click(xy["x"], xy["y"])
    time.sleep(PASTE_DELAY_SEC)

    # clear box then paste
    pyautogui.hotkey("ctrl", "a")
    time.sleep(0.03)
    pyautogui.hotkey("ctrl", "v")
    time.sleep(ENTER_DELAY_SEC)
    pyautogui.press("enter")


# ------------------ Watchdog Handler ------------------
class Handler(FileSystemEventHandler):
    def on_created(self, event):
        if event.is_directory:
            return
        path = Path(event.src_path)
        if path.suffix.lower() != ".json":
            return

        try:
            time.sleep(FILE_STABILIZE_SEC)
            data = read_json_with_retry(path)
            prompt = build_prompt(data)

            OUTBOX.mkdir(exist_ok=True)
            (OUTBOX / f"{path.stem}.prompt.txt").write_text(prompt, encoding="utf-8")

            print(f"[INFO] Injecting: {path.name}", flush=True)

            last_err = None
            for attempt in range(RETRY_PASTE + 1):
                try:
                    paste_into_open_chatgpt(prompt)
                    last_err = None
                    break
                except Exception as e:
                    last_err = e
                    print(f"[WARN] paste attempt {attempt+1} failed: {e}", flush=True)
                    time.sleep(0.8)

            if last_err:
                raise last_err

            PROCESSED.mkdir(exist_ok=True)
            shutil.move(str(path), str(PROCESSED / path.name))
            print(f"[OK] Sent + moved: {path.name}", flush=True)

        except Exception as e:
            FAILED.mkdir(exist_ok=True)
            try:
                shutil.move(str(path), str(FAILED / path.name))
            except Exception:
                pass
            print(f"[FAIL] {path.name}: {e}", flush=True)


def ensure_dirs():
    for d in (INBOX, PROCESSED, FAILED, OUTBOX):
        d.mkdir(exist_ok=True)


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--capture", action="store_true", help="Capture ChatGPT input XY and exit.")
    args = ap.parse_args()

    ensure_dirs()

    if args.capture:
        capture_click_point()
        return

    print("[START] watcher running", flush=True)
    print("[WATCHING]", INBOX.resolve(), flush=True)
    print("Drop .json files into inbox/. Press Ctrl+C to stop.", flush=True)
    print(f"[INFO] XY file: {COORD_FILE}", flush=True)

    observer = Observer()
    observer.schedule(Handler(), str(INBOX), recursive=False)
    observer.start()

    try:
        while True:
            time.sleep(1)
    except KeyboardInterrupt:
        observer.stop()

    observer.join()

def dump_json_block(obj) -> list[str]:
    import json
    return ["```json", json.dumps(obj, ensure_ascii=False, indent=2), "```"]

if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        print(f"[FATAL] {e}", file=sys.stderr)
        sys.exit(1)
